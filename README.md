## Результати тестування

## Результати тестування

| Тест | Сума | Монети | Алгоритм | Час виконання (с) | Результат | Повільніше у разів |
|------|------|--------|----------|------------------|-----------|-------------------|
| 1 | 113 | [50, 25, 10, 5, 2, 1] | Жадібний | 0.0000026226 | {50: 2, 10: 1, 2: 1, 1: 1} | — |
| 1 | 113 | [50, 25, 10, 5, 2, 1] | Динамічне програмування | 0.0000255108 | {50: 2, 10: 1, 2: 1, 1: 1} | 9.73× |
| 2 | 2345 | [50, 25, 10, 5, 2, 1] | Жадібний | 0.0000021458 | {50: 46, 25: 1, 10: 2} | — |
| 2 | 2345 | [50, 25, 10, 5, 2, 1] | Динамічне програмування | 0.0004346371 | {50: 46, 25: 1, 10: 2} | 202.56× |
| 3 | 123456 | [50, 25, 10, 5, 2, 1] | Жадібний | 0.0000023842 | {50: 2469, 5: 1, 1: 1} | — |
| 3 | 123456 | [50, 25, 10, 5, 2, 1] | Динамічне програмування | 0.0260760784 | {50: 2469, 5: 1, 1: 1} | 10937.10× |
| 4 | 40 | [30, 20, 5] | Жадібний | 0.0000035763 | {30: 1, 5: 2} | — |
| 4 | 40 | [30, 20, 5] | Динамічне програмування | 0.0000061989 | {20: 2} | 1.73× |

---

## Висновки

- **Жадібний алгоритм суттєво перевершує динамічне програмування за швидкістю** для канонічних систем монет `[50, 25, 10, 5, 2, 1]`, причому різниця зростає разом зі збільшенням суми.

- **Для великих значень суми динамічне програмування стає непридатним з точки зору продуктивності**, тоді як жадібний алгоритм зберігає майже сталий час виконання.

- **Обидва алгоритми повертають однакові результати** для канонічної системи монет, що підтверджує коректність жадібного підходу у таких випадках.

- **Для неканонічних систем монет жадібний алгоритм не гарантує оптимальності** `[30, 20, 5]`, тоді як динамічне програмування завжди знаходить оптимальне рішення.

- **Практичний вибір алгоритму залежить від умов задачі**: жадібний — для швидких обчислень з канонічними номіналами, динамічне програмування — коли важлива гарантована оптимальність.
